use std::path::PathBuf;

use glam::Mat4;
use metaverse_messages::utils::skeleton::Joint;
use metaverse_messages::utils::skeleton::JointName;
use metaverse_messages::utils::skeleton::Transform;

use glam::Vec3;
use metaverse_messages::{
    capabilities::{item::Item, scene::SceneGroup},
    utils::skeleton::Skeleton,
};
use uuid::Uuid;

// Definitions for an avatar object
#[derive(Debug, Clone)]
/// This contains information about the agent appearances as they come into the scene.
/// this is used to collect agent items, and trigger generation of the GLTF once their assets have
/// been loaded.
pub struct Avatar {
    /// The UUID of the agent
    pub agent_id: Uuid,
    /// How many items are being requested. When the appearance is fully loaded, the outfit_size
    /// and outfit_items will be of equal length.
    pub outfit_size: usize,
    /// The items in the outfit. Contains mesh and other data that will be used to construct the
    /// gltf file.
    pub outfit_items: Vec<OutfitObject>,
    /// The position of the agent in the world
    pub position: Vec3,
    /// The global skeleton of the agent
    pub skeleton: Skeleton,
    /// the location on disk of the avatar model for rendering
    pub path: Option<PathBuf>,
}
impl Avatar {
    pub fn new(agent_id: Uuid, position: Vec3, outfit_size: usize) -> Self {
        Avatar {
            agent_id,
            position,
            outfit_size,
            outfit_items: Vec::new(),
            // default_skeleton.rs is generated by build.rs. This is generated at compile time from the gltf
            // skeleton file in the benthic_default_model dir. It is a Skeleton object, with the
            // default transforms and parent-child relationships hardcoded in. This is used to
            // calculate rotations for the transforms that are given from the server
            skeleton: include!(concat!(env!("OUT_DIR"), "/default_skeleton.rs")),
            path: None,
        }
    }
}

#[derive(Debug, Clone)]
/// The items that can be stored in an outfit. It can contain generic Items, or SceneGroups, which
/// contain mesh data.
pub enum OutfitObject {
    /// A generic item
    Item(Item),
    /// A SceneGroup, containing mesh and render data
    RiggedObject(RiggedObject),
}

// TODO: this may be better as just a scenegroup object
#[derive(Debug, Clone)]
pub struct RiggedObject {
    /// The scenegroup for the rigged object
    pub scene_group: SceneGroup,
    /// the skeleton that defines the joint data of the object
    /// not the global skeleton of the agent
    pub skeleton: Skeleton,
    // TODO: Find a better place for this.
    // the path to the json cache for the object
    pub json_path: PathBuf,
}
